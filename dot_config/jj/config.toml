"$schema" = "https://jj-vcs.github.io/jj/latest/config-schema.json"

[user]
name = "Nathan Witmer"
email = "nathan@zerowidth.com"

[ui]
diff-editor = "gitpatch"
diff-formatter = "difft"
default-command = "status"
bookmark-list-sort-keys = ["committer-date-", "name"]

[colors]
# extra labels for the prompt
mega = {fg = "red", bold = true}
wip = {fg = "yellow", bold = true}
todo = {fg = "blue", bold = true}
vibe = {fg = "cyan", bold = true}
private = {fg = "magenta", bold = true}

[git]
write-change-id-header = true
private-commits = "description(regex-i:'^(wip|todo|private|vibe|mega).*')"

[merge-tools.gitpatch]
program = "sh"
edit-args = ["-c", '''
  set -eu
  rm -f "$right/JJ-INSTRUCTIONS"
  git -C "$left" init -q
  git -C "$left" add -A
  git -C "$left" commit -q -m baseline --allow-empty
  mv "$left/.git" "$right"
  git -C "$right" add --intent-to-add --ignore-removal .
  git -C "$right" add -p
  git -C "$right" diff-index --quiet --cached HEAD && { echo "No changes done, aborting split."; exit 1; }
  git -C "$right" commit -q -m split
  git -C "$right" reset -q --hard
''',
]

merge-args = ["-c", "echo gitpatch cannot be used as a diff tool"]
diff-args = ["-c", "echo gitpatch cannot be used as a diff tool"]

[templates]
# git commit --verbose, kinda:
draft_commit_description = '''
concat(
  description,
  surround(
    "\nJJ: This commit contains the following changes:\n", "",
    indent("JJ:     ", diff.stat(72)),
  ),
  "\nJJ: ignore-rest\n",
  diff.git(),
)
'''

[template-aliases]
'format_short_change_id(id)' = 'id.shortest(4)'
'format_short_commit_id(id)' = 'id.shortest(4)'
'format_timestamp(timestamp)' = 'timestamp.ago()'

'builtin_log_compact(commit)' = '''
if(commit.root(),
  format_root_commit(commit),
  label(
    separate(" ",
      if(commit.current_working_copy(), "working_copy"),
      if(commit.immutable(), "immutable", "mutable"),
      if(commit.conflict(), "conflicted"),
    ),
    concat(
      format_short_commit_header(commit) ++ "\n",
      separate(" ",
        if(commit.empty(), empty_commit_marker),
        if(commit.description(),
          if(commit.description().starts_with("wip"),
            label("wip", "wip") ++ commit.description().first_line().remove_prefix("wip"),
          if(commit.description().starts_with("todo"),
            label("todo", "todo") ++ commit.description().first_line().remove_prefix("todo"),
          if(commit.description().starts_with("vibe"),
            label("vibe", "vibe") ++ commit.description().first_line().remove_prefix("vibe"),
          if(commit.description().starts_with("private"),
            label("private", "private") ++ commit.description().first_line().remove_prefix("private"),
          if(commit.description().starts_with("mega"),
            label("mega", "mega") ++ commit.description().first_line().remove_prefix("mega"),
            commit.description().first_line()
          ))))),
          label(if(commit.empty(), "empty"), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''

# see dot_p10k.zsh.tmpl for usage, this is a p10k prompt output
prompt = '''
separate(" ",
  format_short_change_id_with_change_offset(self),
  format_short_commit_id(commit_id),
  if(empty, label("empty", "(empty)"), ""),
  if(description == "", label("description placeholder", "(no description)"), ""),
  if(description.contains("megamerge"), label("mega", "(mega)"), ""),
  if(description.starts_with("wip"), label("wip", "(wip)"), ""),
  if(description.starts_with("todo"), label("todo", "(todo)"), ""),
  if(description.starts_with("vibe"), label("vibe", "(vibe)"), ""),
  if(description.starts_with("private"), label("private", "(private)"), ""),
  if(conflict, label("conflict", "(conflict)"), "")
)
'''

[revsets]
'log' = 'wip'

[revset-aliases]
# show everything in the current set of branches off of trunk():
# heads(::@ & immutable()) shows the latest immutable parent of @
# ::mutable() combines it with all mutable branches off that immutable commit
branch = 'heads(::@ & immutable())::mutable()'
mine = 'heads(::@ & immutable())::mine(mutable())'
wip = 'stack(mutable() & recent(), 2) | trunk()'
log = 'ancestors(reachable(@, trunk()..), 2) | trunk()'
# log = 'heads(coalesce(trunk(), root()))..present(@) | ancestors(recent(visible_heads()), 2) | present(trunk())'
more = 'log | ancestors(visible_heads(), 2)'
"/" = 'trunk()'

# set all remote bookmarks (and implicitly commits on branches) to be immutable
# github doesn't play nicely with rebase+force push
# 'immutable_heads()' = "builtin_immutable_heads() | remote_bookmarks()"

'closest_bookmark(to)' = 'heads(::to & bookmarks())'
'closest_pushable(to)' = 'heads(::to & mutable() & ~description(exact:"") & (~empty() | merges()))'
'unmerged()' = 'bookmarks() & ~(trunk():: | trunk())'
'recent()' = 'committer_date(after:"3 months ago")'
'recent(revset)' = 'revset & recent()'

'stack()' = 'stack(@)'
'stack(x)' = 'stack(x, 2)'
'stack(x, n)' = 'ancestors(reachable(x, mutable()), n)'
# `stack(x)` shows the entire stack of work for some commit `x` so `stack(@)` is
# often good. I currently use `stack(mine() | @) | trunk() | @` as my global
# default as of recently, which I don't hate. but `stack(@)` is a good default,
# IMO

[aliases]
bl = ["bookmark", "list"]
blr = ["bookmark", "list", "--revisions", "recent()"]
c = ["commit"]
ci = ["commit", "--interactive"] # commit interactive
dp = ["describe", "@-"] # describe previous
e = ["edit"]
pull = ["git", "fetch"]
push = ["git", "push"]
gf = ["git", "fetch"] # git fetchq
gi = ["util", "exec", "--", "sh", "-c", """
jj git init --colocate && jj bookmark track $(jj config get 'revset-aliases."trunk()"') --remote origin
"""]
gp = ["git", "push"]
i = ["git", "init", "--colocate"]
l = ["log", "-r", "more()"]

nb = ["bookmark", "create", "-r @-"] # new bookmark (for creating bookmark to push)
nc = ["new", "-B", "@", "--no-edit"] # new change before
r = ["rebase"]
rm = ["rebase", "-d", "trunk()"] # "re-main"
rma = ["rebase", "-s", "roots(trunk()..) & mutable() & mine()", "-d", "trunk()"] # "re-main all"
s = ["show"]
si = ["squash", "--interactive"]
sp = ["show", "@-"]
up = ["util", "exec", "--", "sh", "-c", """
if [ "x$1" = "x" ]; then
  jj bookmark move --from "closest_bookmark(@)" --to "closest_pushable(@)"
else
  jj bookmark move --to "closest_pushable(@)" "$@"
fi
""", ""]
upp = ["util", "exec", "--", "sh", "-c", "jj up && jj git push", ""]
colocate = ["util", "exec", "--", "zsh", "-c", """
  echo '/*' > .jj/.gitignore && \
  mv .jj/repo/store/git .git && \
  echo '../../../.git' > .jj/repo/store/git_target &&
  git config --unset core.bare && \
  jj new && jj undo
  """]
branch = ["util", "exec", "--", "sh", "-c", """
jj log --no-graph --limit 1 -r "closest_bookmark(@)" -T 'bookmarks.join(" ")' 2>/dev/null | awk '{print $1}'
""", ""]
merge = ["util", "exec", "--", "sh", "-c", """
if [ "x$1" = "x" ]; then
  echo "Usage: jj merge <branch>"
  exit 1
fi
target=$(jj log --no-graph --limit 1 -r "closest_bookmark(@)" -T 'bookmarks.join(" ")' 2>/dev/null | awk '{print $1}')
if [ "x$target" = "x" ]; then
  jj new @ "$1" -m "Merge branch '$1'"
else
  jj new @ "$1" -m "Merge branch '$1' into $target"
fi
""", ""]
watch = ["util", "exec", "--", "sh", "-c", """
target=$(jj log --no-graph --limit 1 -r "closest_bookmark(@)" -T 'bookmarks.join(" ")' 2>/dev/null | awk '{print $1}')
gh pr checks $target --watch --required
""", ""]

[remotes.origin]
auto-track-bookmarks = "main|master"
auto-track-created-bookmarks = "*"
