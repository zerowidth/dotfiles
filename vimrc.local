" ----- janus overrides -----

" set mapleader, so <Leader>-related stuff can be redefined
let mapleader = ','

" rewrite mapleader stuff
map <Leader><Leader> :ZoomWin<CR>
" Opens an edit command with the path of the currently edited file filled in
" not mapped to ,e since that's used by camelcasemotion
map <Leader>o :e <C-R>=expand("%:p:h") . "/" <CR>
" Opens a tab edit command with the path of the currently edited file filled in
map <Leader>te :tabe <C-R>=expand("%:p:h") . "/" <CR>

let NERDTreeIgnore=['\.pyc$', '\.rbc$', '\~$', '^tags$']

" livin' on the edge!
set noswapfile

" ----- my settings -----

" expand tabs, always
set expandtab

" wrap lines at convenient points
set linebreak
" reasonable textwidth (imo)
set textwidth=120

" store lots of :cmdline history
set history=1000

" enable ctrl-n, ctrl-p in tab completion
set wildmenu

" override listchars
set listchars=tab:⋅⋅,trail:⋅,nbsp:⋅

" don't continue comments when pushing o/O
set formatoptions-=o

" disable two-space joins
set nojoinspaces

" folding
set foldenable
" set foldcolumn=4 " show fold column
set foldmethod=syntax " syntax / markers
set foldlevel=3 " start with no folding, but ready to go
set foldminlines=0 " Allow folding single lines
set foldnestmax=3 " Set max fold nesting level

" show at least 3 lines above/below cursor
set scrolloff=3
" and at least 7 columns next to cursor
set sidescrolloff=7
set sidescroll=1

" some stuff to get the mouse going in term
" set mouse=a
" set ttymouse=xterm2

" hide buffers when not displayed (vs. unloading them)
set hidden

" the terminal has 256 color support
set t_Co=256

"map Q to something useful
noremap Q gq

"make Y consistent with C and D
nnoremap Y y$

" auto-change CWD when changing tree root
" let NERDTreeChDirMode=2
command -n=? -complete=dir NT NERDTreeToggle <args>

" include space in comments
" let g:NERDSpaceDelims = 1
" let g:NERDRemoveExtraSpaces = 1

" put commandT window at the top of the screen
let g:CommandTMatchWindowAtTop=1

" disable hammer warning messages (bleh)
let g:HammerQuiet=1

" easy escape
imap jj <Esc>

if !has("gui")
  " set custom cursor -- vertical bar in insert mode (iTerm2)
  " from http://www.iterm2.com/#/section/documentation/escape_codes
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

"make <c-l> clear the highlight as well as redraw
nnoremap <C-L> :nohls<CR><C-L>
inoremap <C-L> <C-O>:nohls<CR>

map <silent> <Leader>r :call Refresh()<CR>

function Refresh()
  echo "refreshing tags and files..."

  silent !ctags -R

  if exists(":CommandTFlush") == 2
    CommandTFlush
  endif

  if exists("t:NERDTreeBufName")
    let nr = bufwinnr(t:NERDTreeBufName)
    if nr != -1
      exe nr . "wincmd w"
      exe substitute(mapcheck("R"), "<CR>", "", "")
      wincmd p
    endif
  endif

endfunction

colorscheme molokai

set colorcolumn=80,120

" from evilchelu:
" get the last pasted text
nnoremap gb '[V']

" current window always has a nice size
set winheight=10
" but the other windows aren't *too* small
" set winminheight=3

" new splits go below the current buffer
set splitbelow
" and to the right as well
set splitright

" strip leading tabs and trailing whitespace
command Tr %s/\s\+$//ge | %s/\t/  /ge | nohlsearch
command FixHashes %s/\(\S\)=>\(\S\)/\1 => \2/ge | %s/\t/  /ge | nohlsearch

" from http://stackoverflow.com/questions/676600/vim-replace-selected-text
vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>
vnoremap <C-a> "hy:Ack <C-r>h

map <leader>tn :tabnew<CR>
map <leader>ta :tabnew<CR>:Ack
map <leader>a :Ack
map <leader>x :x<CR>

" auto-save everything when vim loses focus
au FocusLost * silent! wa

" http://vim.wikia.com/wiki/Disable_F1_built-in_help_key
" nmap <F1> :echo<CR>
" imap <F1> <C-o>:echo<CR>

" auto-reload any file modified outside vim
set autoread

" fix crontab editing
au BufEnter /private/tmp/crontab.* setl backupcopy=yes

" post gists privately by default
" let g:gist_private = 1
" show private gists by default
let g:gist_show_privates = 1

" customization for session plugin to hack
" local sessions stored in "session.vim" for individual projects
" with the assumption that projects are opened, give or take,
" with 'mvim .'
"
" autosave active sessions
let g:session_autosave = 1

map <leader>ss :call CreateLocalSession()<CR>
map <leader>sl :call LoadLocalSession()<CR>
map <leader>sd :DeleteSession<CR>

augroup LocalSession
  au VimEnter * call SetLocalSessionDirectory()
augroup END

function SetLocalSessionDirectory()
  " opening up a specific directory, project-style
  if argc() == 1 && isdirectory(argv(0))
    let g:session_directory = fnamemodify(argv(0), ":p")
  else
    let g:session_directory = getcwd()
  end
endfunction

function LoadLocalSession()
  let oldminheight = &winminheight
  set winminheight=1
  OpenSession session
  let &winminheight=oldminheight
endfunction

function CreateLocalSession()
  let g:session_directory = getcwd()
  SaveSession session
endfunction

" ----- tab movement setup -----
" tab mojo from ara.t.howard

" this lets 'tt' toggle between tabs
let g:tabno=tabpagenr()
au TabLeave * :let g:tabno = tabpagenr()
map tt :exec 'normal !'.g:tabno.'gt'<CR>

" map 'tn' to tabnext - a count is relative from current pos
" function TabNext()
"     exec 'tabn'
" endfunction
" map tn :call TabNext()<CR>

" tab/cursor movement mappings
" note that this overwrites <C-L> for :nohlsearch

" map 'tg' to 'tab go' - this is an absolute tab number and quite useful with 'tt'
" map tg gt
" map <C-j> gt

" map 'tp' to 'tab previous'
" map tp gT
" map <C-k> gT

" ctrl-j and ctrl-k move tabs left(j)/right(k)
" map <C-h> :call TabMove(1)<CR>
" map <C-j> :call TabMove(1)<CR>
" map <C-k> :call TabMove(0)<CR>
" map <C-l> :call TabMove(0)<CR>
function TabMove(n)
    let nr = tabpagenr()
    let size = tabpagenr('$')
    " do we want to go left?
    if (a:n != 0)
        let nr = nr - 2
    endif
    " crossed left border?
    if (nr < 0)
        let nr = size-1
        " crossed right border?
    elseif (nr == size)
        let nr = 0
    endif
    " fire move command
    exec 'tabm'.nr
endfunction

" map <C-J> <C-W>j<C-W>_
" map <C-K> <C-W>k<C-W>_
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
map <C-_> <C-w>_

map <C-Left> :call TabMove(1)<CR>
map <C-Right> :call TabMove(0)<CR>

" ----- syntax copying for presentations -----

" tell TOhtml to disable line numbering when generating HTML
let g:html_number_lines=0
" and to use a reasonable font
let g:html_font="Andale Mono"

" copy the entire buffer or selected text as RTF
" inspired by https://github.com/dharanasoft/rtf-highlight
" but only uses commands available by default on OS X.
"
" To set html conversion options, :help TOhtml
" And, undocumented, to set the font used,
" let g:html_font="Your Preferred Font"
"
function! CopyRTF(line1,line2)
  if !executable('textutil')
    echoerr "crap! textutil not found"
    return
  endif

  call tohtml#Convert2HTML(a:line1, a:line2)
  silent exe "%!textutil -convert rtf -stdin -stdout | pbcopy"
  silent bd!

  echomsg "RTF copied to clipboard"
endfunction

command! -range=% CopyRTF :call CopyRTF(<line1>,<line2>)

" ----- statusline from scrooloose/vimfiles -----

"statusline setup
set statusline=%f       "tail of the filename

"display a warning if fileformat isnt unix
set statusline+=%#warningmsg#
set statusline+=%{&ff!='unix'?'['.&ff.']':''}
set statusline+=%*

"display a warning if file encoding isnt utf-8
set statusline+=%#warningmsg#
set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}
set statusline+=%*

set statusline+=%h      "help file flag
set statusline+=%y      "filetype
set statusline+=%r      "read only flag
set statusline+=%m      "modified flag

"display a warning if &et is wrong, or we have mixed-indenting
set statusline+=%#error#
set statusline+=%{StatuslineTabWarning()}
set statusline+=%*

set statusline+=%{StatuslineTrailingSpaceWarning()}

" set statusline+=%{StatuslineLongLineWarning()}

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

"display a warning if &paste is set
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*

" git status if applicable
set statusline+=%{fugitive#statusline()}

set statusline+=%=      "left/right separator
set statusline+=%{StatuslineCurrentHighlight()}\ \ "current highlight
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ %P    "percent through file
set laststatus=2

"recalculate the trailing whitespace warning when idle, and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_trailing_space_warning

"return '[\s]' if trailing white space is detected
"return '' otherwise
function! StatuslineTrailingSpaceWarning()
    if !exists("b:statusline_trailing_space_warning")
        if search('\s\+$', 'nw') != 0
            let b:statusline_trailing_space_warning = '[\s]'
        else
            let b:statusline_trailing_space_warning = ''
        endif
    endif
    return b:statusline_trailing_space_warning
endfunction


"return the syntax highlight group under the cursor ''
function! StatuslineCurrentHighlight()
    let name = synIDattr(synID(line('.'),col('.'),1),'name')
    if name == ''
        return ''
    else
        return '[' . name . ']'
    endif
endfunction

"recalculate the tab warning flag when idle and after writing
autocmd cursorhold,bufwritepost * unlet! b:statusline_tab_warning

"return '[&et]' if &et is set wrong
"return '[mixed-indenting]' if spaces and tabs are used to indent
"return an empty string if everything is fine
function! StatuslineTabWarning()
    if !exists("b:statusline_tab_warning")
        let tabs = search('^\t', 'nw') != 0
        let spaces = search('^ ', 'nw') != 0

        if tabs && spaces
            let b:statusline_tab_warning =  '[mixed-indenting]'
        elseif (spaces && !&et) || (tabs && &et)
            let b:statusline_tab_warning = '[&et]'
        else
            let b:statusline_tab_warning = ''
        endif
    endif
    return b:statusline_tab_warning
endfunction

"recalculate the long line warning when idle and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_long_line_warning

"return a warning for "long lines" where "long" is either &textwidth or 80 (if
"no &textwidth is set)
"
"return '' if no long lines
"return '[#x,my,$z] if long lines are found, were x is the number of long
"lines, y is the median length of the long lines and z is the length of the
"longest line
function! StatuslineLongLineWarning()
    if !exists("b:statusline_long_line_warning")
        let long_line_lens = s:LongLines()

        if len(long_line_lens) > 0
            let b:statusline_long_line_warning = "[" .
                        \ '#' . len(long_line_lens) . "," .
                        \ 'm' . s:Median(long_line_lens) . "," .
                        \ '$' . max(long_line_lens) . "]"
        else
            let b:statusline_long_line_warning = ""
        endif
    endif
    return b:statusline_long_line_warning
endfunction

"return a list containing the lengths of the long lines in this buffer
function! s:LongLines()
    let threshold = (&tw ? &tw : 80)
    let spaces = repeat(" ", &ts)

    let long_line_lens = []

    let i = 1
    while i <= line("$")
        let len = strlen(substitute(getline(i), '\t', spaces, 'g'))
        if len > threshold
            call add(long_line_lens, len)
        endif
        let i += 1
    endwhile

    return long_line_lens
endfunction

"find the median of the given array of numbers
function! s:Median(nums)
    let nums = sort(a:nums)
    let l = len(nums)

    if l % 2 == 1
        let i = (l-1) / 2
        return nums[i]
    else
        return (nums[l/2] + nums[(l/2)-1]) / 2
    endif
endfunction

